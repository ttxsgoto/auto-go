####
go build 编译自身包和依赖包
go install 编译并安装自身包和依赖包
go doc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档。
go install 是安装 Go 包的工具
go fix 用于将你的 Go 代码从旧的发行版迁移到最新的发行版
go test 是一个轻量级的单元测试框架


#### 关键字
下面列举了 Go 代码中会使用到的 25 个关键字或保留字：

break	    default	    func	interface	select
case	    defer	    go	    map	        struct
chan	    else	    goto	package	    switch
const	    fallthrough	if	    range	    type
continue	for	import	return	var


package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包

所有的包名都应该使用小写字母
每一段代码只会被编译一次

除了符号 _，包中所有代码对象的标识符必须是唯一的，以避免名称冲突

可以通过使用包的别名来解决包名之间的名称冲突 import fm "fmt"


如果你导入了一个包却没有使用它，则会在构建程序时引发错误，如 imported and not used: os，这正是遵循了 Go 的格言：“没有不必要的代码！“


#### 函数
在括号 () 中写入 0 个或多个函数的参数（使用逗号 , 分隔），每个参数的名称后面必须紧跟着该参数的类型
函数里的代码（函数体）使用大括号 {} 括起来。
左大括号 { 必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt 时就会出现错误提示
右大括号 } 需要被放在紧接着函数体的下一行。如果你的函数非常简短，你也可以将它们放在同一行
程序正常退出的代码为 0 即 Program exited with code 0；如果程序因为异常而被终止，则会返回非零值，如：1。
这个数值可以用来测试是否成功执行一个程序
一个函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 () 将它们括起来


#### 注释
单行注释 ， 以 // 开头的单行注释
多行注释(块注释)，以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段


#### 类型
类型可以是基本类型，如：int、float、bool、string；
结构化的（复合的），如：struct、array、slice、map、channel；
只描述类型的行为的，如：interface
Go 语言中不存在类型继承
type 关键字可以定义你自己的类型，

#### 类型转换
由于 Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明，就像调用一个函数一样（类型在这里的作用可以看作是一种函数）

#### go程序的结构
- 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。
- 如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。
- 如果当前包是 main 包，则定义 main 函数。
- 然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。


#### go程序的执行顺序：
1.按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：
2.如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。
3.然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。
4.在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。

#### Go命名规范
干净、可读的代码和简洁性是 Go 追求的主要目标


#### 常量
常量的定义格式：const identifier [type] = value
    - 显式类型定义： const b string = "abc"
    - 隐式类型定义： const b = "abc"
常量的值必须是能够在编译时就能够确定
反斜杠 \ 可以在常量表达式中作为多行的连接符使用
常量还可以用作枚举：
    const (
    	Unknown = 0
    	Female = 1
    	Male = 2
    )

#### 变量
声明变量的一般形式是使用 var 关键字：var identifier type， 声明变量时将变量的类型放在变量的名称之后
    var a, b *int
    var (
    	a int
    	b bool
    	str string
    )       // 这种因式分解关键字的写法一般用于声明全局变量
当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，
string 为空字符串，指针为 nil。所有的内存在 Go 中都是经过初始化的
变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate。
如果你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写（可见性原则)

一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。如果一个变量在函数体外声明，则
被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。

局部变量:在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量

变量可以编译期间就被赋值，赋值给变量使用运算符等号 =

#### 值类型和引用类型
int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值
数组和结构这些复合类型也是值类型,当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝
可以通过 &i 来获取变量 i 的内存地址

一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置
这个内存地址被称之为指针,这个指针实际上也被存在另外的某一个字中
同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），
这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。
当使用赋值语句 r2 = r1 时，只有引用（地址）被复制

引用类型：
    - 指针
    - slices
    - map
    - channel
被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间


#### 使用 := 赋值操作符
    - 它只能被用在函数体内，不可以用于全局变量的声明与赋值
    - 在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明
    - 全局变量是允许声明但不使用

#### init函数
一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高
每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行
用途： 开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性


#### 基本类型和运算符
    - 布尔型 (&& ||)
    - 数字型 (int float32| float64),应该尽可能地使用 float64
    - 字符型

只有两个类型相同的值才可以进行比较，如果值的类型是接口，们也必须都实现了相同的接口
如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的
如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较


#### 指针
Go 语言为程序员提供了控制数据结构的指针的能力；但是，你不能进行指针运算
程序在内存中存储它的值，每个内存块（或字）有一个地址，通常用十六进制数表示，如：0x6b0820 或 0xf84001d7f0
Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址

一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，
在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关

    - 指针的格式化标识符为 %p fmt.Printf("An integer: %d, it's location in memory: %p\n", i1, &i1)
    - 指针类型前面加上 * 号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器
    - 一个指针被定义后没有分配到任何变量时，它的值为 nil， 一个指针变量通常缩写为 ptr
    - 符号 * 可以放在一个指针前，如 *intP，那么它将得到这个指针指向地址上所存储的值；
      这被称为反引用（或者内容或者间接引用）操作符
    - 指针的一个高级应用是你可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝
    - 在大多数情况下 Go 语言可以使程序员轻松创建指针，并且隐藏间接引用，如：自动反向引用

#### 控制结构
  - if-else结构
        if condition1 {
        	// do something
        } else if condition2 {
        	// do something else
        } else {
        	// catch-all or default
        }
        - 即使当代码块之间只有一条语句时，大括号也不可被省略
        - 关键字 if 和 else 之后的左大括号 { 必须和关键字在同一行，如果你使用了 else-if 结构，则前段代码块的右大括号 }
          必须和 else-if 关键字在同一行， 这两条规则都是被编译器强制规定的
        - if 结构内有 break、continue、goto 或者 return 语句时，Go 代码的常见写法是省略 else 部分

  - switch 结构
        switch var1 {
        	case val1:
        		...
        	case val2:
        		...
        	default:
        		...
        }

        - 变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值
        - 类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式
        - 前花括号 { 必须和 switch 关键字在同一行
        - 每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止
        - 一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块,
          不需要特别使用 break 语句来表示结束
        - 如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，
          可以使用 fallthrough 关键字来达到目的
        - default 它的作用类似与 if-else 语句中的 else，表示不符合任何已给出条件时，执行相关语句

  - for 结构
      - 基于计数器的迭代
        for 初始化语句; 条件语句; 修饰语句 {}

        - 三部分组成的循环的头部，它们之间使用分号 ; 相隔，但并不需要括号 () 将它们括起来
        - 左花括号 { 必须和 for 语句在同一行，计数器的生命周期在遇到右花括号 } 时便终止
      - 基于条件判断的迭代
        for 条件语句 {}

      - 无限循环
        条件语句是可以被省略的，如 i:=0; ; i++ 或 for { } 或 for ;; { }

      - for-range结构
        for ix, val := range coll { }
































































